<details>
    <summary>1. 폰노이만 구조와 하버드 구조의 주요 차이점을 설명해주세요.</summary>
    <br>

**두 구조의 핵심 차이는 명령어와 데이터를 어떻게 저장하고 접근하느냐에 있습니다.**

**폰 노이만 구조는 명령어와 데이터가 같은 메모리 공간을 공유합니다.** 하나의 버스를 통해 CPU가 메모리에 접근하기 때문에 명령어를 가져오는 것과 데이터를 읽고 쓰는 작업을 동시에 할 수 없어서 순차적으로 처리해야 합니다. 이 때문에 폰 노이만 병목현상이 발생해서 CPU 성능에 제약이 생기지만, 구조가 단순하고 메모리를 유연하게 사용할 수 있어서 범용 컴퓨터에 적합합니다.

**하버드 구조는 명령어와 데이터를 물리적으로 완전히 분리된 메모리에 저장합니다.** 각각 독립된 버스가 있어서 CPU가 동시에 명령어를 가져오면서 데이터를 처리할 수 있어 병렬성이 뛰어나고 성능이 우수합니다. 하지만 두 개의 메모리와 버스가 필요해서 하드웨어 비용이 높고, 명령어와 데이터 메모리 크기를 미리 정해야 하므로 유연성이 떨어집니다.

</details>

<details>
    <summary>2. 폰 노이만 병목현상이 발생하는 이유와 해결 방법을 설명해주세요.</summary>
    <br>

**폰 노이만 병목현상은 CPU와 메모리 간의 데이터 전송 속도 차이 때문에 발생합니다.**

**근본적인 원인은 단일 버스 구조에 있습니다.** 명령어와 데이터가 같은 메모리 공간과 버스를 공유하기 때문에 CPU가 명령어를 가져오는 동안에는 데이터에 접근할 수 없고, 데이터를 처리하는 동안에는 다음 명령어를 미리 가져올 수 없습니다. 게다가 CPU의 처리 속도는 기하급수적으로 빨라졌지만 메모리 접근 속도는 상대적으로 느리게 발전해서 이 격차가 더욱 벌어지고 있습니다.

**현대 CPU는 여러 기법으로 이 문제를 해결합니다.**

**캐시 메모리가 가장 핵심적인 해결책입니다.** L1, L2, L3 캐시를 계층적으로 구성해서 자주 사용되는 데이터와 명령어를 CPU 가까이에 미리 저장해둡니다. L1 캐시는 명령어 캐시와 데이터 캐시로 분리해서 하버드 구조의 장점까지 활용하고 있습니다.

**파이프라이닝으로 명령어 처리를 병렬화합니다.** Fetch, Decode, Execute, Memory, Write-back 단계를 동시에 진행해서 한 명령어가 실행되는 동안 다음 명령어들을 미리 준비할 수 있게 합니다.

**분기 예측과 추측 실행으로 메모리 접근을 최적화합니다.** CPU가 조건문의 결과를 미리 예측해서 필요한 명령어와 데이터를 사전에 캐시로 가져오고, 예측이 틀렸을 때만 되돌리는 방식으로 평균 성능을 크게 향상시킵니다.

**슈퍼스칼라와 비순차 실행으로 더 많은 작업을 동시에 처리합니다.** 여러 실행 유닛을 두고 의존성이 없는 명령어들을 순서에 상관없이 동시에 실행해서 CPU 활용률을 극대화하고 있습니다.

</details>

<details>
    <summary>3. 수정형 하버드 구조가 두 구조의 장점을 어떻게 결합했는지 설명해주세요.</summary>
    <br>
    
**수정형 하버드 구조는 계층별로 서로 다른 방식을 적용해서 두 구조의 장점만 취합니다.**

**메인 메모리 레벨에서는 폰 노이만 방식을 유지합니다.** 명령어와 데이터가 같은 주소 공간에 저장되어 있어서 메모리를 유연하게 사용할 수 있고, 프로그램이 런타임에 코드를 동적으로 생성하거나 수정하는 것도 가능합니다. 이렇게 하면 메모리 효율성과 비용 효율성을 모두 확보할 수 있습니다.

**캐시 레벨에서는 하버드 방식으로 분리합니다.** L1 캐시를 I-Cache(명령어 캐시)와 D-Cache(데이터 캐시)로 완전히 분리해서 CPU가 동시에 명령어를 가져오면서 데이터를 처리할 수 있게 합니다. 이때 각 캐시는 독립적인 버스로 연결되어 있어서 병렬 접근이 가능하고 성능이 크게 향상됩니다.

**지역성 원리를 활용해서 성능을 극대화합니다.** 대부분의 메모리 접근이 캐시에서 히트되기 때문에 실제로는 하버드 구조의 병렬성 혜택을 받으면서도, 캐시 미스가 발생했을 때만 메인 메모리의 폰 노이만 방식으로 순차 처리합니다.

</details>

<details>
    <summary>4. 현대 CPU에서 I-Cache와 D-Cache를 분리하는 이유를 설명해주세요.</summary>
    <br>

**I-Cache와 D-Cache 분리는 명령어와 데이터의 서로 다른 접근 패턴을 최적화하기 위함입니다.**

**명령어와 데이터는 근본적으로 다른 특성을 가집니다.** 명령어는 주로 순차적으로 접근되고 읽기 전용이며 지역성이 매우 강합니다. 반면 데이터는 랜덤 접근이 많고 읽기와 쓰기가 모두 발생하며 접근 패턴이 불규칙적입니다. 이런 차이 때문에 각각에 특화된 캐시 설계가 필요합니다.

**병렬 처리로 성능을 크게 향상시킵니다.** 분리된 캐시는 독립적인 포트를 가지고 있어서 CPU가 동시에 명령어를 페치하면서 데이터를 로드하거나 스토어할 수 있습니다. 특히 슈퍼스칼라 프로세서에서 여러 명령어를 동시에 처리할 때 이 병렬성이 결정적인 성능 차이를 만듭니다.

**캐시 충돌을 완전히 제거합니다.** 통합 캐시에서는 대용량 데이터 처리 시 데이터가 명령어를 밀어내서 명령어 캐시 미스가 급증할 수 있습니다. 분리된 구조에서는 데이터 접근이 아무리 많아도 명령어 캐시에 영향을 주지 않아서 안정적인 성능을 보장합니다.

**각각에 최적화된 설계를 적용할 수 있습니다.** I-Cache는 순차 프리페칭과 더 큰 라인 사이즈로 최적화하고, D-Cache는 다양한 replacement policy와 write policy로 최적화할 수 있습니다. 또한 I-Cache는 ECC가 덜 중요하지만 D-Cache는 데이터 무결성이 critical하므로 서로 다른 보호 메커니즘을 적용합니다.

</details>
