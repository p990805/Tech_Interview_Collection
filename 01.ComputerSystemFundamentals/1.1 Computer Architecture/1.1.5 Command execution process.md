<details>
    <summary>1. 명령어 사이클의 Fetch-Decode-Execute 과정을 상세히 설명해주세요.</summary>
    <br>

**"CPU가 명령어를 처리하는 과정은 크게 세 단계로 나뉩니다."**

**Fetch(인출) 단계**에서는 먼저 프로그램 카운터(PC)가 가리키는 메모리 주소에서 명령어를 가져옵니다. 이 주소가 메모리 주소 레지스터(MAR)에 저장되고, 해당 위치의 명령어가 메모리 데이터 레지스터(MDR)를 거쳐 명령어 레지스터(IR)로 이동합니다. 동시에 PC는 자동으로 다음 명령어 주소로 증가해서 연속적인 실행을 준비합니다.

**Decode(해석) 단계**에서는 제어 유닛이 IR에 저장된 명령어를 분석합니다. 명령어의 연산 코드(Opcode)를 해석해서 어떤 동작을 수행해야 하는지 파악하고, 피연산자(Operand) 정보를 통해 필요한 데이터나 레지스터 위치를 확인합니다. 이 과정에서 제어 유닛은 다음 단계에서 필요한 제어 신호들을 준비합니다.

**Execute(실행) 단계**에서는 해석된 명령어에 따라 실제 작업이 수행됩니다. 산술 연산이면 ALU가 계산을 수행하고, 데이터 이동 명령이면 레지스터나 메모리 간 데이터 전송이 일어나며, 분기 명령이면 PC 값이 변경됩니다. 결과는 지정된 레지스터나 메모리 위치에 저장되고, 다음 명령어 사이클이 시작됩니다.

이 세 단계가 반복되면서 프로그램 전체가 순차적으로 실행되는 것입니다.

</details>

<details>
    <summary>2. 파이프라닝의 동작 원리와 성능 향상 효과를 설명해주세요.</summary>
    <br>
    
**"파이프라이닝은 CPU 성능을 극적으로 향상시키는 핵심 기술입니다."**

**동작 원리**는 세탁소 비유로 설명할 수 있습니다. 전통적인 방식은 한 벌의 옷을 세탁→건조→다림질까지 완전히 끝낸 후 다음 옷을 처리하는 것과 같습니다. 하지만 파이프라이닝은 첫 번째 옷이 세탁 중일 때 두 번째 옷을 세탁기에 대기시키고, 첫 번째 옷이 건조기로 넘어가면 즉시 두 번째 옷을 세탁하는 방식입니다.

CPU에서는 **명령어 1이 Decode 단계**에 있을 때, **명령어 2는 Fetch 단계**를 동시에 수행합니다. 명령어 1이 Execute로 넘어가면 명령어 2는 Decode로, 명령어 3은 새로 Fetch를 시작하죠. 이렇게 여러 명령어의 서로 다른 단계가 동시에 진행됩니다.

**성능 향상 효과**는 매우 큽니다. 파이프라인 없이는 명령어 하나당 3 사이클이 걸린다면, 4개 명령어 처리에 12 사이클이 필요합니다. 하지만 3단계 파이프라인에서는 초기 3 사이클 후 매 사이클마다 하나씩 명령어가 완료되어 총 6 사이클만 소요됩니다. **이론적으로는 파이프라인 단계 수만큼 성능이 향상**됩니다.

다만 **데이터 해저드**(이전 명령어 결과를 다음 명령어가 바로 필요로 할 때)나 **제어 해저드**(분기 명령으로 실행 흐름이 바뀔 때) 같은 문제로 실제 성능 향상은 이론치보다 낮습니다. 이를 해결하기 위해 분기 예측이나 데이터 포워딩 같은 기술들이 함께 사용됩니다.

</details>

<details>
    <summary>3. 파이프라이닝에서 발생하는 해저드는 크게 세 가지 유형이 있으며, 각각 다른 해결 방법이 필요합니다.</summary>
    <br>

**"파이프라이닝에서 발생하는 해저드는 크게 세 가지 유형이 있으며, 각각 다른 해결 방법이 필요합니다."**

- **데이터 해저드(Data Hazard)** 는 명령어 간 데이터 의존성 때문에 발생합니다. 예를 들어 `ADD R1, R2, R3` 다음에 `SUB R4, R1, R5`가 오면, 첫 번째 명령어의 R1 결과가 나오기 전에 두 번째 명령어가 R1을 읽으려고 해서 문제가 생깁니다.
  이는 **데이터 포워딩(Forwarding)** 으로 해결합니다. ALU의 출력을 직접 다음 명령어의 ALU 입력으로 우회시켜 메모리나 레지스터를 거치지 않고 즉시 전달하는 방식입니다. 불가능한 경우엔 **파이프라인 스톨(Stall)** 을 통해 일시 정지시킵니다.
- **제어 해저드(Control Hazard)** 는 분기 명령어 때문에 발생합니다. `BEQ R1, R2, LABEL` 같은 조건 분기에서 조건 검사 결과가 나오기 전까지는 다음에 어떤 명령어를 가져와야 할지 알 수 없어서 파이프라인이 멈춥니다.
- **분기 예측(Branch Prediction)** 으로 해결합니다. 과거 분기 패턴을 분석해서 조건이 참일지 거짓일지 미리 예측하고, 예측한 방향의 명령어들을 미리 파이프라인에 넣습니다. 예측이 틀리면 잘못 실행된 명령어들을 버리고 올바른 경로부터 다시 시작합니다. 현대 CPU는 90% 이상의 높은 예측 정확도를 달성합니다.
- **구조적 해저드(Structural Hazard)** 는 하드웨어 자원 부족으로 발생합니다. 예를 들어 명령어 인출과 데이터 접근이 동시에 같은 메모리를 사용하려고 할 때 충돌이 생깁니다.

**하드웨어 중복 설계**로 해결합니다. 명령어 캐시와 데이터 캐시를 분리하거나, 메모리 포트를 여러 개 만들어서 동시 접근을 가능하게 합니다. 비용 문제로 불가능하면 스케줄링을 통해 자원 사용 시점을 조정합니다.

</details>

<details>
    <summary>4. 분기 예측의 필요성과 성능에 미치는 영향을 설명해주세요.</summary>
    <br>

**"분기 예측은 현대 고성능 CPU에서 절대적으로 필요한 기술입니다."**

**분기 예측의 필요성**은 파이프라이닝의 근본적인 한계에서 나옵니다. 일반적인 프로그램에서 분기 명령어는 전체 명령어의 **15-25%**를 차지합니다. 조건문, 반복문, 함수 호출이 모두 분기 명령어이기 때문이죠. 문제는 분기 결과가 결정되는 시점이 파이프라인의 뒤쪽 단계라는 점입니다.

예를 들어 5단계 파이프라인에서 분기 조건이 3번째 단계에서 계산된다면, 그때까지 이미 2개의 후속 명령어가 파이프라인에 들어가 있습니다. 분기가 발생하면 이 명령어들을 모두 버리고 올바른 위치부터 다시 시작해야 하므로 **2-3 사이클의 지연**이 발생합니다.

**성능에 미치는 영향**은 매우 큽니다. 분기 예측 없이는 분기 명령어마다 평균 2-3 사이클씩 손실되므로, 전체 성능이 **30-50% 저하**될 수 있습니다. 현대 CPU처럼 10-20단계의 깊은 파이프라인에서는 잘못된 분기로 인한 손실이 더욱 커집니다.

**분기 예측기의 동작 방식**은 과거 패턴을 학습합니다. **1비트 예측기**는 마지막 결과만 기억해서 단순하지만, 반복문에서 마지막에 한 번 분기하지 않을 때 연속으로 두 번 틀리는 문제가 있습니다. **2비트 예측기**는 강한 분기/약한 분기 상태를 둬서 더 안정적입니다.

고급 기법으로는 **글로벌 히스토리**를 활용해 여러 분기 명령어의 상관관계를 분석하거나, **두 단계 적응형 예측기**로 지역 패턴과 전역 패턴을 모두 고려합니다. 현대 CPU는 **95% 이상의 예측 정확도**를 달성해서 분기로 인한 성능 손실을 최소화합니다.

결국 분기 예측 없이는 파이프라이닝의 성능 이점을 제대로 활용할 수 없기 때문에, 고성능 CPU에서는 필수불가결한 기술입니다.

</details>
