<details>   
<summary>1. 운영체제의 4가지 주요 역할을 설명해주세요.</summary>
<br>

**"운영체제는 컴퓨터 시스템의 핵심 관리자로서 네 가지 주요 역할을 담당합니다."**

**첫 번째로 프로세스 관리는 운영체제의 가장 중요한 역할입니다.** 여러 프로그램이 동시에 실행될 때 CPU를 어떤 프로세스에 할당할지 결정하는 CPU 스케줄링을 담당합니다. 프로세스의 생성과 종료를 관리하고, 프로세스 간 통신과 동기화를 지원해서 데드락을 방지합니다. 마치 여러 직원의 업무를 조율하는 관리자처럼 시스템 자원을 효율적으로 배분합니다.

**두 번째로 메모리 관리는 한정된 RAM을 효율적으로 활용하는 역할입니다.** 각 프로세스에 메모리 공간을 할당하고 회수하며, 가상 메모리 시스템을 통해 물리 메모리보다 큰 프로그램도 실행할 수 있게 합니다. 페이징과 세그멘테이션을 통해 메모리 단편화를 방지하고, 메모리 보호 기능으로 프로세스 간 간섭을 막습니다.

**세 번째로 파일 시스템 관리는 데이터의 영구 저장과 조직화를 담당합니다.** 하드디스크나 SSD에 파일을 저장하고 검색하는 인터페이스를 제공하며, 디렉토리 구조로 파일을 체계적으로 관리합니다. 파일 접근 권한을 제어하고, 백업과 복구 기능을 지원해서 데이터 무결성을 보장합니다.

**네 번째로 입출력 관리는 다양한 하드웨어 장치와의 통신을 조율합니다.** 키보드, 마우스, 프린터, 네트워크 카드 등 수많은 장치들과 프로그램 사이의 인터페이스 역할을 하며, 장치 드라이버를 통해 하드웨어 제어를 표준화합니다. 버퍼링과 스풀링을 통해 입출력 효율성을 높이고, 인터럽트 처리로 실시간 응답성을 보장합니다.

</details>

<details>   
<summary>2. 사용자 인터페이스와 시스템 인터페이스의 차이점을 설명해주세요.</summary>
<br>

**"운영체제는 두 가지 서로 다른 대상을 위한 인터페이스를 제공합니다."**

**사용자 인터페이스(UI)는 일반 사용자가 컴퓨터와 상호작용하기 위한 창구입니다.** Windows의 바탕화면, 맥OS의 Dock, 리눅스의 터미널 같은 것들이 대표적인 예시입니다. 사용자가 마우스 클릭이나 키보드 입력을 통해 직관적으로 컴퓨터를 조작할 수 있게 해주며, 그래픽 환경(GUI)이나 명령어 환경(CLI) 형태로 제공됩니다. 복잡한 시스템 내부 구조를 몰라도 파일 복사, 프로그램 실행 같은 작업을 쉽게 할 수 있게 추상화되어 있습니다.

**시스템 인터페이스(API)는 응용 프로그램이 운영체제의 기능을 호출하기 위한 프로그래밍 인터페이스입니다.** 시스템 콜이 가장 대표적인 예시로, 프로그램이 파일을 읽고 쓰거나, 네트워크 통신을 하거나, 메모리를 할당받을 때 사용합니다. open(), read(), write(), malloc() 같은 함수들이 실제로는 커널의 기능을 호출하는 시스템 콜입니다. 개발자가 하드웨어를 직접 제어하지 않고도 안전하고 표준화된 방법으로 시스템 자원에 접근할 수 있게 해줍니다.

**핵심 차이점은 대상과 목적입니다.** 사용자 인터페이스는 사람이 컴퓨터를 사용하기 위한 것이고, 시스템 인터페이스는 프로그램이 운영체제와 통신하기 위한 것입니다. 사용자 인터페이스는 편의성과 직관성을 중시하지만, 시스템 인터페이스는 정확성과 효율성을 중시합니다.

</details>

<details>   
<summary>3. 운영체제가 관리하는 자원의 종류와 관리 방법을 설명해주세요.</summary>
<br>

**"운영체제는 컴퓨터의 한정된 자원들을 효율적으로 배분하고 관리하는 핵심 역할을 담당합니다."**

**CPU 자원 관리는 가장 중요한 영역 중 하나입니다.** 여러 프로세스가 동시에 실행을 요청할 때 CPU 스케줄링 알고리즘을 통해 공정하고 효율적으로 배분합니다. Round Robin으로 시간을 나누어 할당하거나, 우선순위 기반으로 중요한 작업을 먼저 처리하며, 멀티코어 환경에서는 로드 밸런싱을 통해 각 코어의 부하를 균등하게 분산시킵니다. 컨텍스트 스위칭을 통해 프로세스 간 전환을 관리하고, 시분할 시스템으로 마치 동시에 실행되는 것처럼 보이게 합니다.

**메모리 자원 관리는 RAM의 효율적인 활용에 집중합니다.** 각 프로세스에 독립적인 메모리 공간을 할당하고, 가상 메모리 시스템을 통해 물리 메모리보다 큰 프로그램도 실행할 수 있게 합니다. 페이징과 세그멘테이션으로 메모리를 효율적으로 분할하고, LRU나 FIFO 같은 페이지 교체 알고리즘으로 자주 사용되지 않는 데이터를 디스크로 스왑합니다. 메모리 보호 기능으로 프로세스 간 침범을 방지하고 시스템 안정성을 확보합니다.

**저장장치 자원 관리는 데이터의 영구 보존과 빠른 접근을 보장합니다.** 파일 시스템을 통해 데이터를 체계적으로 조직화하고, 디스크 스케줄링 알고리즘(SCAN, C-SCAN 등)으로 헤드 이동을 최적화해서 I/O 성능을 향상시킵니다. 버퍼링과 캐싱을 통해 자주 접근하는 데이터를 메모리에 유지하고, RAID 시스템으로 데이터 안정성과 성능을 동시에 확보합니다.

**입출력 장치 자원 관리는 다양한 하드웨어와의 원활한 소통을 담당합니다.** 장치 드라이버를 통해 키보드, 마우스, 프린터, 네트워크 카드 등을 표준화된 방법으로 제어하고, 인터럽트 처리 시스템으로 실시간 응답성을 보장합니다. 스풀링으로 느린 장치의 출력을 대기열로 관리하고, DMA를 통해 CPU 개입 없이 직접 메모리 전송을 수행해서 시스템 효율성을 높입니다.

</details>

<details>   
<summary>4. 프로세스와 프로그램의 차이점을  설명해주세요.</summary>
<br>

**"프로그램과 프로세스는 정적인 것과 동적인 것의 차이로 이해할 수 있습니다."**

**프로그램은 디스크에 저장된 정적인 코드 덩어리입니다.** Chrome.exe, Photoshop.exe, game.py 같은 실행 파일들이 대표적인 예시입니다. 하드디스크나 SSD에 저장되어 있는 명령어와 데이터의 집합으로, 아직 실행되지 않은 상태입니다. 마치 책장에 꽂혀있는 요리책처럼 잠재적인 기능은 있지만 실제로 동작하지는 않는 상태입니다. 같은 프로그램이 여러 번 실행되어도 디스크의 원본 파일은 변하지 않습니다.

**프로세스는 메모리에 적재되어 실제로 실행 중인 프로그램의 인스턴스입니다.** 운영체제가 프로그램을 메모리로 로드하고 CPU를 할당해서 명령어를 실행하는 순간 프로세스가 됩니다. 각 프로세스는 고유한 PID(Process ID)를 가지며, 독립적인 메모리 공간(코드, 데이터, 스택, 힙 영역)을 할당받습니다. 실행 상태, 대기 상태, 종료 상태 등의 생명주기를 가지며 동적으로 변화합니다.

**핵심 차이점은 상태와 자원 할당입니다.** 하나의 프로그램으로 여러 개의 프로세스를 만들 수 있습니다. 예를 들어 Chrome 브라우저를 여러 창으로 열면, Chrome.exe라는 하나의 프로그램에서 여러 개의 프로세스가 생성됩니다. 각 프로세스는 독립적인 메모리를 가지고 서로 다른 웹사이트를 표시할 수 있습니다.

**실무 관점에서 보면** 작업 관리자에서 보이는 실행 중인 항목들이 프로세스이고, 프로그램 설치 폴더에 있는 .exe 파일들이 프로그램입니다. 개발할 때 코드를 작성하면 프로그램을 만드는 것이고, 그 코드를 실행하면 프로세스가 생성되는 것입니다.

**메모리 관점에서** 프로그램은 디스크 공간만 차지하지만, 프로세스는 RAM 공간을 차지하며 CPU 시간도 소비합니다. 이것이 시스템 성능에 직접적인 영향을 미치는 이유입니다.

</details>
