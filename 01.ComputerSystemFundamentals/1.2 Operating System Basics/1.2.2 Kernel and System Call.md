<details>
    <summary>1. 커널의 역할과 사용자 영역과의 차이점을 설명해주세요.</summary>
    <br>
    
"커널은 운영체제의 **핵심 부분**으로, 하드웨어와 애플리케이션 사이에서 **중재자 역할**을 담당합니다."

커널의 가장 중요한 역할은 **시스템 자원 관리**입니다. CPU 스케줄링을 통해 여러 프로세스가 공정하게 CPU를 사용하도록 조율하고, 메모리 관리를 통해 각 프로세스가 안전하게 메모리 공간을 할당받아 사용할 수 있게 보장합니다. 또한 파일 시스템 관리, 디바이스 드라이버 제어, 네트워크 통신 등 **하드웨어와 직접 상호작용하는 모든 저수준 작업**을 처리합니다.

사용자 영역과의 핵심 차이점은 **실행 권한과 접근 범위**입니다. 커널은 **커널 모드**에서 실행되어 시스템의 모든 자원에 제한 없이 접근할 수 있습니다. 반면 사용자 영역의 프로그램들은 **사용자 모드**에서 실행되며, 보안상 하드웨어 직접 접근이 금지됩니다.

메모리 공간도 **완전히 분리**되어 있습니다. 커널은 보호된 커널 공간을 사용하고, 사용자 프로그램들은 각각 독립된 가상 메모리 공간을 할당받습니다. 사용자 프로그램이 파일 읽기나 네트워크 통신 같은 작업을 하려면 반드시 **시스템 콜**을 통해 커널에 요청해야 합니다. 이때 **모드 전환**이 발생하면서 커널이 대신 작업을 수행하고 결과를 돌려주는 방식으로 **시스템의 안정성과 보안**을 보장합니다.

</details>

<details>
    <summary>2. 시스템 콜이 필요한 이유와 동작 과정을 설명해주세요.</summary>
    <br>
    
"시스템 콜은 **사용자 프로그램이 커널 서비스를 요청하기 위한 유일한 통로**입니다."

시스템 콜이 필요한 가장 중요한 이유는 **보안과 안정성 보장**입니다. 만약 사용자 프로그램이 하드웨어에 직접 접근할 수 있다면, 악의적인 프로그램이 시스템을 망가뜨리거나 다른 프로그램의 메모리를 침범할 수 있습니다. 따라서 **하드웨어 접근을 커널이 독점**하고, 사용자 프로그램은 반드시 커널을 통해서만 하드웨어를 사용할 수 있도록 제한합니다.

또한 **자원 관리의 일관성**을 위해서도 필요합니다. 여러 프로그램이 동시에 파일을 읽거나 네트워크를 사용할 때, 커널이 중앙에서 조율해야 충돌 없이 안전하게 작업할 수 있습니다.

**시스템 콜의 동작 과정**을 설명드리면, 먼저 사용자 프로그램이 `read()` 같은 라이브러리 함수를 호출합니다. 이 함수가 **시스템 콜 번호와 매개변수를 CPU 레지스터에 설정**하고, **소프트웨어 인터럽트**를 발생시켜 **사용자 모드에서 커널 모드로 전환**합니다.

커널 모드로 전환되면 **인터럽트 핸들러**가 시스템 콜 번호를 확인해서 **시스템 콜 테이블**에서 해당하는 커널 함수를 찾아 실행합니다. 커널 함수가 실제 하드웨어 작업을 처리한 후, **결과를 레지스터에 저장**하고 **사용자 모드로 복귀**합니다.

예를 들어 파일을 읽을 때는, 커널이 파일 시스템을 통해 디스크에서 데이터를 읽어와 사용자 버퍼에 복사하고, 읽은 바이트 수를 반환합니다. 이 과정에서 **모드 전환 오버헤드**가 발생하지만, 시스템의 안정성을 위해 반드시 필요한 메커니즘입니다.

</details>

<details>
    <summary>3. 사용자 모드와 커널 모드 전환 과정을 설명해주세요.</summary>
    <br>
    
 "모드 전환은 **CPU의 권한 수준을 변경하는 핵심 메커니즘**으로, 시스템의 보안과 안정성을 보장합니다."

**사용자 모드에서 커널 모드로 전환하는 과정**을 말씀드리면, 사용자 프로그램이 시스템 콜을 호출하면 **소프트웨어 인터럽트**가 발생합니다. 이 순간 **CPU가 자동으로 현재 실행 상태를 보존**합니다. 구체적으로는 **프로그램 카운터, 스택 포인터, 범용 레지스터 값들**을 모두 커널 스택에 저장하고, **CPU의 모드 비트를 0으로 변경**해서 커널 모드로 전환됩니다.

그 다음 **인터럽트 벡터 테이블**을 참조해서 해당하는 **인터럽트 핸들러 주소로 점프**합니다. 이때 중요한 것은 **사용자 스택에서 커널 스택으로 전환**된다는 점입니다. 커널이 시스템 콜 번호를 확인하고 **시스템 콜 테이블에서 적절한 커널 함수를 찾아 실행**합니다.

**커널 모드에서 사용자 모드로 복귀하는 과정**은 반대입니다. 커널 함수가 작업을 완료하면 **결과값을 특정 레지스터에 저장**하고, **복귀 명령어**를 실행합니다. 이때 이전에 저장했던 **사용자 프로그램의 모든 실행 상태를 복원**합니다. **프로그램 카운터, 스택 포인터, 레지스터 값들**을 원래대로 되돌리고, **CPU의 모드 비트를 1로 설정**해서 사용자 모드로 복귀합니다.

**모드 전환의 오버헤드**도 고려해야 할 중요한 부분입니다. 레지스터 저장과 복원, 캐시 무효화, TLB 플러시 등으로 인해 **상당한 시간이 소요**됩니다. 하지만 이는 **시스템 보안과 안정성을 위해 반드시 감수해야 하는 비용**입니다.

가장 중요한 점은 모든 모드 전환이 **하드웨어 차원에서 강제적으로 이루어진다**는 것입니다. 사용자 프로그램이 임의로 커널 모드로 전환할 수 없고, 오직 **인터럽트, 예외, 시스템 콜을 통해서만 가능**합니다.

</details>

<details>
    <summary>4. Modebit의 역할과 모드 전환 시 값이 변화를 설명해주세요.</summary>
    <br>
    
"Modebit는 **CPU 내부의 특별한 레지스터 비트**로, 현재 실행 중인 프로그램의 **권한 수준을 나타내는 핵심 지표**입니다."

Modebit는 **0과 1 두 가지 값**만 가질 수 있습니다. **0은 커널 모드(특권 모드)**를 의미하고, **1은 사용자 모드**를 의미합니다. CPU가 명령어를 실행할 때마다 **이 비트를 먼저 확인**해서 해당 명령어를 실행할 권한이 있는지 판단합니다.

예를 들어 **I/O 명령어, 메모리 관리 명령어, 인터럽트 제어 명령어** 같은 특권 명령어들은 Modebit가 0일 때만 실행 가능합니다. 만약 사용자 모드에서 이런 명령어를 실행하려고 하면 **하드웨어가 자동으로 예외를 발생**시켜 커널이 해당 프로세스를 강제 종료시킵니다.

**모드 전환 시 Modebit 변화**를 설명하면, **사용자 모드에서 커널 모드로 전환**될 때, 시스템 콜이나 인터럽트가 발생하면 **CPU가 자동으로 Modebit를 0으로 설정**합니다. 이는 소프트웨어가 아닌 **하드웨어에서 강제적으로 처리**되는 과정입니다.

**커널 모드에서 사용자 모드로 복귀**할 때는 **복귀 명령어 실행과 동시에 Modebit가 1로 변경**됩니다. 이때 중요한 것은 **커널만이 Modebit를 변경할 수 있다**는 점입니다. 사용자 프로그램은 절대 임의로 이 값을 조작할 수 없습니다.

Modebit는 **시스템 보안의 최후 방어선** 역할을 합니다. 모든 하드웨어 접근과 특권 명령어 실행을 **하드웨어 차원에서 실시간으로 검증**하므로, 소프트웨어 버그나 악의적인 코드로도 우회할 수 없습니다. 또한 **멀티태스킹 환경에서 프로세스 간 보호**도 제공합니다. 각 프로세스가 자신만의 사용자 모드에서 실행되므로, 다른 프로세스나 시스템 자원에 함부로 접근할 수 없게 됩니다.

</details>

<details>
    <summary>5. 시스템 콜 오버헤드가 발생하는 이유를 설명해주세요.</summary>
    <br>
    
</details>
