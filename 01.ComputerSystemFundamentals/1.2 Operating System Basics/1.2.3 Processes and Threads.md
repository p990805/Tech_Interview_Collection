<details>
    <summary>1. 프로세스 메모리 구조를 설명해주세요.</summary>
    <br>
    
"프로세스 메모리 구조는 **프로그램이 실행될 때 메모리에 할당되는 영역**을 **용도별로 체계적으로 분리한 구조**입니다."

**코드 영역(텍스트 영역)**부터 말씀드리면, 이 영역은 **실행 가능한 기계어 코드**가 저장되는 곳입니다. 컴파일된 프로그램의 명령어들이 **읽기 전용**으로 저장되어 있어서 **실행 중에 변경될 수 없습니다**. 같은 프로그램을 여러 번 실행해도 **코드는 동일하므로 메모리에서 공유**할 수 있어 효율적입니다.

**데이터 영역**은 **전역 변수와 정적 변수**가 저장되는 공간입니다. 이 영역은 다시 **초기화된 데이터 영역**과 **초기화되지 않은 데이터 영역(BSS)**으로 나뉩니다. 초기화된 전역 변수는 **프로그램 시작 시 미리 설정된 값**을 가지고, BSS 영역의 변수들은 **자동으로 0으로 초기화**됩니다. **프로그램 실행 내내 존재**하는 특징이 있습니다.

**힙 영역**은 **동적 메모리 할당**을 위한 공간입니다. `malloc()`, `new` 같은 함수로 **런타임에 메모리를 요청**할 때 사용됩니다. 힙은 **낮은 주소에서 높은 주소로 성장**하며, **프로그래머가 직접 할당과 해제를 관리**해야 합니다. 메모리 누수나 댕글링 포인터 같은 **메모리 관리 오류**가 발생할 수 있는 영역입니다.

**스택 영역**은 **함수 호출과 지역 변수**를 위한 공간입니다. 함수가 호출될 때마다 **스택 프레임**이 생성되어 **매개변수, 지역 변수, 리턴 주소**가 저장됩니다. 스택은 **높은 주소에서 낮은 주소로 성장**하며, 함수가 종료되면 **자동으로 해제**됩니다. **LIFO(Last In, First Out) 구조**로 관리되어 **빠른 할당과 해제**가 가능합니다.

**메모리 성장 방향**을 보면, **힙은 위쪽으로, 스택은 아래쪽으로 성장**해서 서로 만나면 **스택 오버플로우**가 발생합니다. 이런 구조로 **각 영역의 용도가 명확히 분리**되어 있어서 **메모리 관리가 효율적**이고, **프로그램의 안정성**도 보장됩니다.

운영체제는 **가상 메모리 시스템**을 통해 각 프로세스마다 **독립적인 메모리 공간**을 제공하므로, 프로세스 간에 **메모리 영역이 겹치지 않고** 서로 **간섭하지 않습니다**.

</details>

<details>
    <summary>2. 스택 영역과 힙 영역의 차이점과 사용 목적을 설명해주세요.</summary>
    <br>

"스택 영역과 힙 영역은 **메모리 관리 방식과 사용 목적이 완전히 다른 두 영역**입니다."

**메모리 할당 방식**부터 말씀드리면, **스택은 자동 관리**로 함수 호출 시 자동 할당되고 함수 종료 시 자동 해제됩니다. 반면 **힙은 수동 관리**로 `malloc()`, `free()` 같은 함수로 프로그래머가 직접 관리해야 합니다.

**접근 속도**는 **스택이 훨씬 빠릅니다**. **LIFO 구조**로 단순하게 스택 포인터만 이동하면 되고 CPU 캐시 지역성도 좋습니다. **힙은 상대적으로 느리고** 메모리 단편화 때문에 접근 패턴이 불규칙합니다.

**사용 목적**을 보면, **스택은 함수 호출 관리**에 사용됩니다. **지역 변수, 매개변수, 리턴 주소**를 저장합니다. **힙은 동적 데이터 구조**를 위한 공간으로, **크기가 실행 시점에 결정되는 배열이나 연결 리스트** 같은 자료구조에 사용합니다.

**메모리 크기**도 차이가 있습니다. **스택은 보통 수 MB로 제한**되어 있어 큰 지역 변수나 깊은 재귀 호출 시 스택 오버플로우가 발생할 수 있습니다. **힙은 시스템 메모리 범위 내에서 자유롭게** 사용 가능합니다.

**생명 주기**를 보면, **스택 데이터는 함수 범위 내에서만 유효**하고, **힙 데이터는 명시적으로 해제할 때까지 계속 존재**합니다. 따라서 **함수를 넘나드는 데이터는 반드시 힙에 저장**해야 합니다.

**오류 패턴**도 다른데, **스택은 주로 스택 오버플로우**, **힙은 메모리 누수나 댕글링 포인터** 같은 문제가 발생합니다.

</details>

<details>
    <summary>3. BSS와 Data 영역의 차이점을 설명해주세요.</summary>
    <br>
    
"BSS와 Data 영역은 **전역 변수와 정적 변수를 저장하는 영역**이지만, **초기화 여부에 따라 구분**됩니다."

**Data 영역**은 **초기화된 전역 변수와 정적 변수**가 저장되는 공간입니다. 예를 들어 `int global_var = 10;` 같이 **컴파일 타임에 초기값이 지정된 변수들**이 여기에 위치합니다. 이 영역의 데이터들은 **실행 파일에 실제 초기값이 포함**되어 있어서 **프로그램 로딩 시 해당 값들이 메모리에 복사**됩니다.

**BSS 영역**은 **초기화되지 않은 전역 변수와 정적 변수**가 저장되는 공간입니다. `int global_var;` 같이 **초기값이 명시되지 않은 변수들**이 여기에 위치합니다. BSS는 **Block Started by Symbol**의 줄임말로, 이 영역의 모든 변수들은 **프로그램 시작 시 자동으로 0으로 초기화**됩니다.

**메모리 효율성** 측면에서 큰 차이가 있습니다. **Data 영역은 실행 파일 크기를 증가**시킵니다. 초기값들이 실제로 파일에 저장되어야 하기 때문입니다. 반면 **BSS 영역은 실행 파일 크기에 영향을 주지 않습니다**. 단지 **얼마나 많은 메모리가 필요한지 정보만 저장**하고, 실제 프로그램 로딩 시에 **운영체제가 0으로 채운 메모리 영역을 할당**합니다.

**초기화 과정**도 다릅니다. **Data 영역은 디스크에서 메모리로 복사**하는 과정이 필요하고, **BSS 영역은 단순히 0으로 클리어**하기만 하면 됩니다. 따라서 **BSS 영역이 프로그램 로딩 속도 면에서 더 유리**합니다.

**실제 사용 예시**를 들면, 큰 배열을 선언할 때 `int arr[1000000] = {0};`으로 하면 Data 영역에 가서 실행 파일이 커지지만, `int arr[1000000];`으로 하면 BSS 영역에 가서 **실행 파일 크기는 증가하지 않으면서도 자동으로 0으로 초기화**됩니다.

**컴파일러 최적화** 관점에서도, 초기값이 0인 전역 변수는 **자동으로 BSS 영역으로 배치**되어 효율성을 높입니다. 결국 **메모리 사용량은 동일하지만 디스크 공간과 로딩 시간을 절약**할 수 있는 것이 BSS 영역의 핵심 장점입니다.

</details>

<details>
    <summary>4. 프로세스 상태(New, Ready, Running, Waiting, Terminated)를 설명해주세요.</summary>
    <br>
    
"프로세스는 **실행 과정에서 5가지 상태**를 가지며, **운영체제가 이 상태들을 관리**합니다."

**New 상태**는 **프로세스가 막 생성된 상태**입니다. 사용자가 프로그램을 실행했을 때 **운영체제가 프로세스를 만들어 메모리에 로드**하고 있는 단계입니다. 아직 **CPU를 할당받을 준비가 완료되지 않은** 상태입니다.

**Ready 상태**는 **실행할 준비가 모두 완료된 상태**입니다. **메모리 할당, 초기화가 끝나서** CPU만 할당받으면 바로 실행할 수 있습니다. 여러 프로세스가 **Ready Queue에서 대기**하면서 **스케줄러의 선택을 기다리는** 상태입니다.

**Running 상태**는 **CPU를 할당받아 실제로 실행 중인 상태**입니다. **명령어가 CPU에서 실제로 처리되고 있는** 단계입니다. **단일 CPU 시스템에서는 한 번에 하나의 프로세스만** Running 상태가 될 수 있습니다.

**Waiting 상태**는 **어떤 이벤트를 기다리며 대기하는 상태**입니다. **I/O 작업 완료, 파일 읽기, 사용자 입력** 등을 기다릴 때 이 상태가 됩니다. **CPU를 할당받아도 진행할 수 없는** 상태이므로 **다른 프로세스에게 CPU를 양보**합니다.

**Terminated 상태**는 **프로세스 실행이 완료된 상태**입니다. **정상 종료나 오류로 인한 강제 종료** 모두 이 상태에 해당합니다. **사용하던 자원들을 모두 반납**하고 **프로세스 정보를 정리하는** 단계입니다.

**상태 전환 과정**을 설명하면, **New → Ready**는 **초기화 완료 시** 일어나고, **Ready → Running**은 **스케줄러가 선택할 때** 발생합니다. **Running → Ready**는 **타임 슬라이스가 끝나거나 더 높은 우선순위 프로세스가 나타날 때** 일어납니다.

**Running → Waiting**은 **I/O 요청이나 자원 대기가 필요할 때** 발생하고, **Waiting → Ready**는 **기다리던 이벤트가 완료되었을 때** 일어납니다. **Running → Terminated**는 **프로세스가 정상 종료되거나 강제 종료될 때** 발생합니다.

**실무에서 중요한 점**은 **Waiting 상태의 프로세스가 많으면** 시스템 성능이 좋아질 수 있다는 것입니다. **CPU가 다른 프로세스를 처리할 수 있어서** 전체적인 처리량이 증가하기 때문입니다.

**운영체제는 각 상태별로 큐를 관리**해서 **효율적인 프로세스 스케줄링**을 수행합니다.

</details>

<details>
    <summary>5. 멀티프로세싱의 장단점을 설명해주세요.</summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>

<details>
    <summary></summary>
    <br>
    
</details>
